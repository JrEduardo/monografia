\documentclass[nohyper, justified, svgnames]{tufte-handout}
\geometry{
  left=2cm, % left margin
  top=2cm,
  marginparwidth=6cm,
  bottom=2cm
}
\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{booktabs}
\usepackage{url}

\makeatletter

\title{Modelo de Regressão COM-Poisson: \textbf{defoliation}}
\author{Eduardo E. R. Junior \& Walmes M. Zeviani}
\date{}
\newcommand{\noun}[1]{\textsc{#1}}

\renewcommand{\textfraction}{0.05}
\renewcommand{\topfraction}{0.8}
\renewcommand{\bottomfraction}{0.8}
\renewcommand{\floatpagefraction}{0.75}

\usepackage[breaklinks=true,pdfstartview=FitH]{hyperref}
\hypersetup{colorlinks, allcolors=., urlcolor=DarkBlue}

\makeatother

\begin{document}
<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
opts_chunk$set(fig.path = 'images/', 
               cache.path = 'cache/',
               cache = FALSE,
               family = "Palatino",
               echo = FALSE,
               warning = FALSE,
               message = FALSE,
               size = "scriptsize",
               comment = NA)

options(formatR.arrow = TRUE, width = 78)
knit_hooks$set(par = function(before, options, envir){
    if (before) par(mar = c(4, 4, .1, .1),
                    cex.lab = .95,
                    cex.axis = .9,
                    mgp = c(2, .7, 0),
                    tcl = -.3)
})

@

<<solarized-theme, cache=FALSE>>=
thm = knit_theme$get("nightshimmer")
knit_theme$set(thm)
@

<<packs>>=
##----------------------------------------------------------------------
## Pacotes gráficos e de manipulação de dados
require(lattice)
require(latticeExtra)
require(plyr)

library(legTools)
data(defoliation)
library(CompGLM)
## help(package = "CompGLM", h = "html")
@


\maketitle
\begin{abstract}
Esta \textit{vignette}\footnote{código fonte disponível em 
\url{https://gitlab.c3sl.ufpr.br/eerj12/tcc_eduardo}} faz parte do 
trabalho de conclusão de curso em Estatística na Universidade Federal do 
Paraná que objetiva a exploração de modelos de regressão para variáveis 
de contagem, por Eduardo Junior sob orientação de Walmes Zeviani.
\end{abstract}


\section{Conjunto de dados}

O cojunto de dados\footnote{Veja detalhes em: \textbf{Impacto de diferentes níveis de desfolha artificial nos estádios fenológicos do algodoeiro.}  \\
\url{http://www.scielo.mec.pt/pdf/rca/v35n1/v35n1a16.pdf}} contém \Sexpr{nrow(defoliation)} observações 
provenientes de um experimento em casa de vegetação inteiramente 
casualizado com 5 repetições, cujo plantas de algodão 
(\textit{Gossypium hirsutum}) foram submetidas à níveis de desfolha 
artificial (5 níveis) combinados com o estágio fenológico da planta na aplicação (5 níveis). As variáveis presente no conjunto de dados são:

\begin{margintable}
Visualizando os dados no R.
<<str, echo = TRUE>>=
## git <- paste0(
##     "http://git.leg.ufpr.br/",
##     "leg/legTools.git")
## devtools::install_git(git)

library(legTools); data(defoliation)

summary(defoliation[, c(1, 2)])
summary(defoliation[, -c(1, 2)])
@

Encurtando nomes, para facilitar a escrita dos códigos
<<encurta, echo = TRUE>>=
## Estreitando nomes
defol <- defoliation
(names(defol) <- substr(
    names(defoliation), 1, 3))
@

\end{margintable}

\begin{itemize}
  \item \texttt{phenol}: estágio fenológico durante a aplicação da 
  desfolha (\textit{
  \Sexpr{paste(levels(defoliation$phenol), collapse = ", ")}});
  \item \texttt{defol}: nível de desfolha artificial aplicado (
  \Sexpr{paste(unique(defoliation$defol), collapse = ", ")});
  \item \texttt{bolls}: número de capulhos produzidos ao final da ciclo
  cultura
\end{itemize}

Pela Figura \ref{fig:descritivo} notamos a relevância das covariáveis 
do estudo, pois as curvas de suavização são razoavelmente distintas para
cada estágio (\texttt{phenol}) e há uma tendência evidente ao considerar 
a variação do nível de desfolha (\texttt{defol}) aplicado, em (a) e (b).
Além disso, de forma complementar o gráfico em (c) apresenta as médias
e variâncias amostrais calculadas nas repetições de cada tratamento e 
notamos a clara evidência de subdispersão, pois todos os pontos estão 
abaixo da linha 1 pra 1 que representa a equidispersão.

\pagebreak

\begin{fullwidth}
<<descritivo, fig.height=4, fig.width=10>>=

##----------------------------------------------------------------------
## Visualizando os dados
panel.beeswarm <- function(x, y, subscripts, r, ...){
    xx <- x; yy <- y
    aux <- by(cbind(yy, xx, subscripts), xx,
              function(i){
                  or <- order(i[,1])
                  ys <- i[or,1]
                  yt <- table(ys)
                  dv <- sapply(unlist(yt),
                               function(j){
                                   seq(1,j,l=j)-(j+1)/2
                               })
                  if(!is.list(dv)){ dv <- as.list(dv) }
                  xs <- i[or,2]+r*do.call(c, dv)
                  cbind(x=xs, y=ys, subscripts[or])
              })
    aux <- do.call(rbind, aux)
    panel.xyplot(aux[,1], aux[,2], subscripts=aux[,3], ...)
}

## Calculando as médias e variâncias entre as repetições de cada
## tratamento 
aux1 <- ddply(defol, .(def, phe), summarise,
              m = mean(bol), v = var(bol))

## Gráficos de dispersão 
p1 <- xyplot(bol ~ def | phe, data = defol,
             layout = c(3, 2), as.table = 1, col = 1,
             xlim = extendrange(c(0:1),f = 0.15),
             xlab = "Nível de desfolha artificial",
             ylab = "Número de capulhos produzidos",
             type = c("p","smooth"), grid = TRUE,
             col.line = "gray50", jitter.x = TRUE, 
             strip = strip.custom(bg = "gray90",
                                  factor.levels = levels(defol$phe)),
             panel = panel.beeswarm, r = 0.05)

## Media vs variancia
p2 <- xyplot(v ~ m, aux1, aspect = "iso",
             col = 1, type = c("p", "g", "r"),
             lty = 1,
             col.line = "gray50", 
             jitter.x = TRUE,
             xlab = expression(Média~amostral~(bar(y))),
             ylab = expression(Variância~amostral~(s^2)), 
             xlim = c(0, 11), ylim = c(0, 11),
             panel = function(...) {
                 panel.xyplot(...)
                 panel.abline(a = 0, b = 1, lty = 2)
             })

## Dispersão geral: nº capulhos vs. nivel de desfolha
p3 <- xyplot(bol ~ def, data = defol,
             col = 1,
             xlim = extendrange(c(0:1), f = 0.15),
             xlab = "Nível de desfolha artificial",
             ylab = "Número de capulhos produzidos",
             type = c("p","smooth"), grid = TRUE,
             col.line = "gray50", lwd = 2, 
             panel = panel.beeswarm, r = 0.01)

print(p1, split = c(1, 1, 2, 1), more = TRUE)
print(p2, split = c(2, 1, 2, 1))
# print(p3, split = c(2, 1, 2, 2))

@

\stepcounter{figure}
\smallskip\noindent\small Figura \thefigure:
(a) Número de capulhos produzidos pelo nível de desfolha estratificado 
por estágio da planta. (b) Variâncias em funçãos das médias amostrais 
calculadas com basa nas 5 repetições de cada tratamento
\end{fullwidth}

\section{Modelos propostos}

Nesta seção ajustamos modelos estatísticos com 3 diferentes distribuições marginais, $[Y \mid X]$ associadas, \textit{Poisson}, 
\textit{Gamma Count}\footnote{As análises foram baseadas em \textbf{The 
Gamma-count distribution in the analysis of experimental underdispersed
data} \\
\url{http://www.leg.ufpr.br/~walmes/papercompanions/gammacount2014/papercomp.html}}
e \textit{COM-Poisson}. Para comparação considerou-se o ajuste do modelo
\textit{quasi-Poisson}. Além disso diferentes estruturas para o preditor
linear foram consideradas:

\begin{itemize}
    \item {\tt Modelo 0:} $\beta_0$ (1 parâmetro)
    \item {\tt Modelo 1:} $\beta_0 + \beta_1 def$ (2 parâmetros)
    \item {\tt Modelo 2:} $\beta_0 + \beta_1 def + \beta_2 def^2$
    (3 parâmetros)
    \item {\tt Modelo 3:} $\beta_0 + \beta_{1phe} def + \beta_2 
    def^2$  (7 parâmetros)
    \item {\tt Modelo 4:} $\beta_0 + \beta_{1phe} def + \beta_{2phe}
    def^2$ (11 parâmetros)
\end{itemize}


<<functions, include=FALSE>>=
##-------------------------------------------
## Pacotes
require(ellipse)
require(rootSolve)
require(CompGLM)

##======================================================================
## Funções de estimação e resumo da gamma count

##-------------------------------------------
## Log-lokelihodd function for the gamma count regression model.

ll <- function(theta, y, X){
    ## theta: parameter vector;
    ## y: response vector (counts);
    ## X: model matrix;
    eXb <- exp(X%*%theta[-1])
    ## returns the log-likelihood.
    sum(log(pgamma(1, theta[1]*y, theta[1]*eXb)-
            pgamma(1, theta[1]*y+theta[1], theta[1]*eXb)))
}

#-------------------------------------------
## Function to estimate gamma count using estimates based on Poisson as
## guess values.

poi2cg <- function(m0){
    ## m0: an aobject of class glm;
    form <- formula(m0)
    form.split <- strsplit(as.character(form), "~")
    yobs <- m0$data[,form.split[[2]]]
    X <- model.matrix(m0)
    alpha <- 1; gamma <- coef(m0)
    op <- optim(c(alpha, gamma), ll, y=yobs, X=X,
                method="L-BFGS-B", hessian=TRUE,
                lower=c(0,rep(-Inf,length(gamma))),
                upper=c(Inf,rep(Inf,length(gamma))),
                control=list(fnscale=-1))
    return(op)
}

##-------------------------------------------
## Likelihood ratio test for a nested sequence of gamma count models.

anova.cg <- function(...){
    cg.list <- list(...)
    lls <- sapply(cg.list, function(x) x$value)
    nps <- sapply(cg.list, function(x) length(x$par))
    cst <- 2*diff(lls)
    pvs <- pchisq(cst, df=diff(nps), lower.tail=FALSE)
    data.frame(ll=lls, npar=nps, two.ll.dif=c(NA,cst),
               npar.dif=c(NA,diff(nps)), pvalue=c(NA,pvs))
}

##-------------------------------------------
## Table of estimatimates, standard error, z and p values. 

summary.cg <- function(m0, conf.int=0.95){
    est <- m0$par
    sdt <- sqrt(diag(-solve(m0$hessian)))
    zval <- est/sdt
    pval <- 2*pnorm(abs(zval), lower=FALSE)
    ci <- est+outer(sdt, c(1,-1)*qnorm((1-conf.int)/2), "*")
    cbind(Estimate=est, Std.Error=sdt, "z value"=zval, "P(>|z|)"=pval,
          lwr=ci[,1], upr=ci[,2])
}

##======================================================================
## Funções para resumo da COM-Poisson
anova.cmp <- function(...){
    cmp.list <- list(...)
    lls <- sapply(cmp.list, function(x) x$logLik)
    nps <- sapply(cmp.list, function(x) nrow(x$hessian))
    cst <- 2 * diff(lls)
    pvs <- pchisq(cst, df = diff(nps), lower.tail = FALSE)
    data.frame(ll = lls, npar = nps, two.ll.dif = c(NA, cst),
               npar.dif = c(NA, diff(nps)), pvalue = c(NA, pvs))
}
@

<<estima, echo = TRUE, cache=TRUE>>=

##----------------------------------------------------------------------
## Estimação dos modelos

##-------------------------------------------
## Modelo Poisson
cpP0 <- glm(bol ~ 1, data = defol, family = poisson)
cpP1 <- glm(bol ~ def, data = defol, family = poisson)
cpP2 <- glm(bol ~ def + I(def^2), data = defol, family = poisson)
cpP3 <- glm(bol ~ phe:def + I(def^2), data = defol, family = poisson)
cpP4 <- glm(bol ~ phe:(def + I(def^2)), data = defol, family = poisson)

##-------------------------------------------
## Modelo Quase Poisson
cpQ0 <- glm(formula(cpP0), data = defol, family = quasipoisson)
cpQ1 <- glm(formula(cpP1), data = defol, family = quasipoisson)
cpQ2 <- glm(formula(cpP2), data = defol, family = quasipoisson)
cpQ3 <- glm(formula(cpP3), data = defol, family = quasipoisson)
cpQ4 <- glm(formula(cpP4), data = defol, family = quasipoisson)

##-------------------------------------------
## Modelo Contagem Gama
cpG0 <- poi2cg(cpP0)
cpG1 <- poi2cg(cpP1)
cpG2 <- poi2cg(cpP2)
cpG3 <- poi2cg(cpP3)
cpG4 <- poi2cg(cpP4)

##-------------------------------------------
## Modelo COM-poisson
cpC0 <- glm.comp(formula(cpP0), data = defol)
cpC1 <- glm.comp(formula(cpP1), data = defol)
cpC2 <- glm.comp(formula(cpP2), data = defol)
cpC3 <- glm.comp(formula(cpP3), data = defol)
cpC4 <- glm.comp(formula(cpP4), data = defol)
@

<<>>=
library(xtable)
tab <- data.frame(
    "Modelos" = 0:4,
    "Gamma Count" = anova.cg(cpG0, cpG1, cpG2, cpG3, cpG4)$ll,
    "COM-Poisson" = anova.cmp(cpC0, cpC1, cpC2, cpC3, cpC4)$ll)

xtab <- xtable(tab, label = 'logliks', 
               caption = 'Log-verossimilhanças')
@

<<results='asis'>>=
print(xtab, floating.environment = 'margintable',
      include.rownames = FALSE,
      latex.environments = "",
      table.placement = NULL,
      caption.placement = "top")
@

<<anovas, echo = TRUE>>=
anova(cpP0, cpP1, cpP2, cpP3, cpP4, test = "Chisq")
anova(cpQ0, cpQ1, cpQ2, cpQ3, cpQ4, test = "F")
anova.cg(cpG0, cpG1, cpG2, cpG3, cpG4)
anova.cmp(cpC0, cpC1, cpC2, cpC3, cpC4)
@


\end{document}
